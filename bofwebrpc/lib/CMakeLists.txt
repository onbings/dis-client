
include(GNUInstallDirs)
# get_cmake_property(_variableNames VARIABLES)
# list (SORT _variableNames)
# foreach (_variableName ${_variableNames})
#     message(STATUS "${_variableName}=${${_variableName}}")
# endforeach()

# =============
# == SOURCES ==
# =============

set(PUBLIC_INCLUDES_FILES
)
if (EMSCRIPTEN)
set(API_FILES
	webrpcversioninfo.h   #generated in binary build dir with configure_file
	include/webrpc/webrpc.h
	src/webrpc.cpp
	include/webrpc/grpc.h
	src/grpc.cpp
)
else()
set(API_FILES
	webrpcversioninfo.h   #generated in binary build dir with configure_file
	include/webrpc/webrpc.h
	src/webrpc.cpp
	include/webrpc/websocket.h
	src/websocket.cpp
	include/webrpc/grpc.h
	src/grpc.cpp
)
endif()

set(SOURCES_FILES
	${API_FILES}
)

# For Visual Studio
#source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR}/include/webrpc PREFIX "public" FILES ${PUBLIC_INCLUDES_FILES})
#source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR}/src            PREFIX "src"    FILES ${SOURCES_FILES})

source_group("Api"		 FILES ${API_FILES})

configure_file (${CMAKE_CURRENT_SOURCE_DIR}/include/webrpc/webrpcversioninfo.h.in ${CMAKE_CURRENT_BINARY_DIR}/webrpcversioninfo.h @ONLY)

# ===========
# == BUILD ==
# ===========

if (MSVC)
    # warning level 4 and all warnings as errors
#    add_compile_options(/bigobj)
else()
    # lots of warnings and all warnings as errors
#    add_compile_options(-Wall -Wextra -pedantic -Werror)
endif()

add_library(webrpc
  ${PUBLIC_INCLUDES_FILES}
  ${SOURCES_FILES}
)

# Alias with the namespaced version (consistency)
add_library(ONBINGS::webrpc ALIAS webrpc)

# Includes
target_include_directories(webrpc
  PUBLIC
	#Header path used at build time
	$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>  
    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>		#for webrpc_export.h install (below) and webrpcversioninfo.h (above)
	#Header path used when installed
	$<INSTALL_INTERFACE:include>
)


# Link
target_link_libraries(webrpc
  PUBLIC

  PRIVATE
    #ONBINGS::onbings-another-lib
	#submodule
    #ONBINGS::bofstd
    bofstd
    websockets	#in this order
	$<IF:$<TARGET_EXISTS:uv_a>,uv_a,uv> #in this order
    protobuf::libprotoc 
    protobuf::libprotobuf 
    protobuf::libprotobuf-lite
    gRPC::gpr 
    gRPC::grpc 
    gRPC::grpc++ 
    gRPC::grpc++_alts  
    flatbuffers::flatbuffers
    libevent::core 
    libevent::extra
    thrift::thrift
    thriftz::thriftz 
    thriftnb::thriftnb
)

if(WIN32)
target_link_libraries(webrpc
  PUBLIC

  PRIVATE
)
else()
  if( ANDROID )
  else()
    if(UNIX)
       target_link_libraries(webrpc
         PRIVATE
	       rt
       )
    endif()
  endif()
endif()	

# Defines
#use external libfmt lib instead of the bundled one
#disable exception in spd log and replace thme by assert(false) to avoid try around every sprintf
target_compile_definitions(webrpc
  PUBLIC
	#-DBOFSTD_BUILD_MEDIAINFO_AS_LIBRARY=1	#MediaInfo dll is a shame -> use only the static lib version

  PRIVATE
    -Dwebrpc_EXPORTS=1	#in lower case to define the SYMBOL WEBRPC_EXPORT (upper case)in webrpc_export.h
	-DCRT_SECURE_NO_WARNINGS
	-DCRT_NONSTDC_NO_DEPRECATE
	-DWINSOCK_DEPRECATED_NO_WARNINGS
)

# Features (We need at least C++11 support)
target_compile_features(webrpc
  PUBLIC
    cxx_std_14
)

# ================
# == VERSIONING ==
# ================

# Set version
if(WEBRPC_ENABLE_VERSIONING)
  # Under Linux this function will create the
  # library file with the full version name
  # and the proper symlinks.
  # e.g.
  #  libwebrpc.so.1.0.1
  #  libwebrpc.so.1 --> libwebrpc.so.1.0.1
  set_target_properties(webrpc PROPERTIES
    VERSION   ${PROJECT_VERSION}
    SOVERSION ${PROJECT_VERSION_MAJOR}
  )
endif()

# ====================
# == API management ==
# ====================

include(GenerateExportHeader)

# This CMake function generates a header file (i.e. webrpc_export.h)
# that contains all the proper 'defines' to import/export symbols
# (e.g. BOFSTD_EXPORT) for shared libraries. When building as static
# those macros are simply blank. This file will be by default generated
# into ${CMAKE_CURRENT_BINARY_DIR} (see target_include_directories above)
generate_export_header(webrpc)

# ==================
# == INSTALLATION ==
# ==================

if(NOT APPLE)

  # Fix RPATH upon installation by replacing
  # the absolute RPATH generated by the compiler
  # by a keyword that basically says 'look for my
  # dependencies in the directory I'm currently
  # installed'.
  set_target_properties(webrpc PROPERTIES
    INSTALL_RPATH $ORIGIN
  )

endif()

# Install the target runtime
	   
install(
  TARGETS  webrpc
  EXPORT   webrpc
  RUNTIME  DESTINATION        ${CMAKE_INSTALL_BINDIR}     # For binaries and dll
           COMPONENT          webrpc-runtime
  LIBRARY  DESTINATION        ${CMAKE_INSTALL_LIBDIR}     # For shared libraries
           COMPONENT          webrpc-runtime
           NAMELINK_COMPONENT webrpc-devel
  ARCHIVE  DESTINATION        ${CMAKE_INSTALL_LIBDIR}     # For static libraries
           COMPONENT          webrpc-devel
)
### endif()		   

# Install the public headers (don't forget the generated export directives)
install(DIRECTORY   ${CMAKE_CURRENT_SOURCE_DIR}/include/
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        COMPONENT   webrpc-devel
)
install(FILES       ${CMAKE_CURRENT_BINARY_DIR}/webrpc_export.h
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        COMPONENT   webrpc-devel
)


install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/help/html/. DESTINATION doc COMPONENT doc OPTIONAL)

#set_target_properties(webrpc PROPERTIES FOLDER Lib)

