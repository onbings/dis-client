/*
 * Copyright (c) 2015-2020, Onbings. All rights reserved.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 * PURPOSE.
 *
 * This module defines the bof module interface
 *
 * Name:        bofosd.h
 * Author:      Bernard HARMEL: onbings@gmail.com
 * Web:			    onbings.dscloud.me
 * Revision:    1.0
 *
 * Rem:         Nothing
 *
 * History:
 *
 * V 1.00  Dec 26 2013  BHA : Initial release
 */
#pragma once
/*
cmake -DCMAKE_TOOLCHAIN_FILE=C:/pro/vcpkg/scripts/buildsystems/vcpkg.cmake -DBUILD_SHARED_LIBS=OFF
-DVCPKG_TARGET_TRIPLET=evs-x64-windows-static -DBOFSTD_GENERATE_HELP=ONN C:/pro/github/bofstd
*/
#include "boferr.h"
#include <cstdint>
#include <functional>
#include <memory>
#include <sstream>
#include <stdint.h>
#include <string.h>
#include <string>

using BofAssertCallback =
    std::function<BOFERR(const std::string &_rFile_S, uint32_t _Line_U32, const std::string &_rMasg_S)>;

#include <bofstd_export.h> //Autogenerated by cmake

#define BOF onbings::bof
#define BEGIN_BOF_NAMESPACE() \
  namespace onbings           \
  {                           \
  namespace bof               \
  {
#define END_BOF_NAMESPACE() \
  }                         \
  }
#define USE_BOF_NAMESPACE() using namespace BOF;

BEGIN_BOF_NAMESPACE()

struct BOFSTDPARAM
{
  // Input Param
  bool AssertInRelease_B;
  BofAssertCallback AssertCallback;

  // Output param
  std::string OsName_S;
  std::string ComputerName_S;
  std::string Version_S;

  BOFSTDPARAM()
  {
    Reset();
  }

  void Reset()
  {
    AssertInRelease_B = false;
    AssertCallback = nullptr;
    OsName_S = "";
    ComputerName_S = "";
    Version_S = "";
  }
};
template <typename T> // Can be uint8_t or float
struct BOF_RGBA
{
  T r; /*! Color R component(Red)*/
  T g; /*! Color G component(Greeen)*/
  T b; /*! Color B component(Blue)*/
  T a; /*! Color alpha component(Opacity)*/
  BOF_RGBA()
  {
    Reset();
  }

  BOF_RGBA(T _r, T _g, T _b, T _a)
  {
    r = _r;
    g = _g;
    b = _b;
    a = _a;
  }

  void Reset()
  {
    r = 0;
    g = 0;
    b = 0;
    a = 0;
  }
};
template <typename T>
struct BOF_YUVA
{
  T y; /*! Color Y component(Luminance)*/
  T u; /*! Color U component(Chrominance)*/
  T v; /*! Color V component(Chrominance)*/
  T a; /*! Color alpha component(Opacity)*/
  BOF_YUVA()
  {
    Reset();
  }

  BOF_YUVA(T _y, T _u, T _v, T _a)
  {
    y = _y;
    u = _u;
    v = _v;
    a = _a;
  }

  void Reset()
  {
    y = 0;
    u = 0;
    v = 0;
    a = 0;
  }
};

template <typename T>
struct BOF_SIZE
{
  T Width;  /*! Width value*/
  T Height; /*! Height value*/
  BOF_SIZE()
  {
    Reset();
  }

  BOF_SIZE(T _Width, T _Height)
  {
    Width = _Width;
    Height = _Height;
  }

  void Reset()
  {
    Width = 0;
    Height = 0;
  }
};
template <typename T>
struct BOF_RECT;

template <typename T>
struct BOF_POINT_2D
{
  T x; /*! Point x coordinate*/
  T y; /*! Point y coordinate*/
  BOF_POINT_2D()
  {
    Reset();
  }

  BOF_POINT_2D(T _x, T _y)
  {
    x = _x;
    y = _y;
  }

  void Reset()
  {
    x = 0;
    y = 0;
  }

  bool IsInside(const BOF_RECT<T> &_rBox) const
  {
    return ((x >= _rBox.Left) && (x <= _rBox.Right) && (y >= _rBox.Top) && (y <= _rBox.Bottom));
  }
};

template <typename T>
struct BOF_RECT
{
  T Left;   /*! Rectangle zone left x position*/
  T Right;  /*! Rectangle zone right x position outside of rect: Width_U32  = (_rRect_X.Right_S32 - _rRect_X.Left_S32)*/
  T Top;    /*! Rectangle zone top y position*/
  T Bottom; /*! Rectangle zone bottom y position outside of rect: Height_U32 = (_rRect_X.Bottom_S32 - _rRect_X.Top_S32);*/
  BOF_RECT()
  {
    Reset();
  }

  BOF_RECT(BOF_POINT_2D<T> _TopLeft_X, BOF_POINT_2D<T> _BottomRight_X)
  {
    Top = _TopLeft_X.y;
    Left = _TopLeft_X.x;
    Bottom = _BottomRight_X.y;
    Right = _BottomRight_X.x;
  }

  BOF_RECT(T _x, T _y, T _Width, T _Height)
  {
    Left = _x;
    Right = _x + _Width;
    Top = _y;
    Bottom = _y + _Height;
  }

  void Reset()
  {
    Left = 0;
    Right = 0;
    Top = 0;
    Bottom = 0;
  }

  bool IsInside(const BOF_RECT<T> &_rBox) const
  {
    return ((_rBox.Left <= Left) && (_rBox.Right >= Right)  && (_rBox.Top <= Top) && (_rBox.Bottom >= Bottom));
  }

  T Width() const
  {
    return Right - Left;
  }

  T Height() const
  {
    return Bottom - Top;
  }

  BOF_SIZE<T> Size() const
  {
    return BOF_SIZE<T>(Width(), Height());
  }
};
template <typename T>
struct BOF_POINT_3D
{
  T x; /*! Point x coordinate*/
  T y; /*! Point y coordinate*/
  T z; /*! Point z coordinate*/
  BOF_POINT_3D()
  {
    Reset();
  }

  BOF_POINT_3D(T _x, T _y, T _z)
  {
    x = _x;
    y = _y;
    z = _z;
  }

  void Reset()
  {
    x = 0;
    y = 0;
    z = 0;
  }
};

template <typename T>
struct BOF_POINT_4D
{
  T x; /*! Point x coordinate*/
  T y; /*! Point y coordinate*/
  T z; /*! Point z coordinate*/
  T w; /*! Point w coordinate*/
  BOF_POINT_4D()
  {
    Reset();
  }

  BOF_POINT_4D(T _x, T _y, T _z, T _w)
  {
    x = _x;
    y = _y;
    z = _z;
    w = _w;
  }

  void Reset()
  {
    x = 0;
    y = 0;
    z = 0;
    w = 0;
  }
};

#define BOF_PI 3.14159265358979323846
#define BOF_SQAURE_2 1.41421356237309504880
#define BOF_EULER_NUMBER 2.71828182845904523536
#define BOF_EULER_CONSTANT 0.57721566490153286060

#define BOF_HANDLE uintptr_t
// typedef void *BOF_HANDLE;
// #define BOF_INVALID_HANDLE_VALUE    ((BOF_HANDLE)-1)
const uintptr_t BOF_INVALID_HANDLE_VALUE = ((uintptr_t)-1);
#define BOF_IS_HANDLE_VALID(handle) \
  (((uintptr_t)(handle) != 0) && ((uintptr_t)(handle) != BOF::BOF_INVALID_HANDLE_VALUE)) // && ((uintptr_t)(handle) != 0xCCCCCCCCCCCCCCCC) && ((uintptr_t)(handle) != 0xCDCDCDCDCDCDCDCD) && ((uintptr_t)(handle) != 0xDDDDDDDDDDDDDDDD))
#if defined(__cplusplus)
#define BOF_EXTERN_C extern "C"
#else
#define BOF_EXTERN_C
#endif

// Can be used with __FILE__
#define BOF_GET_FILE_FROM_PATH(pPath, pFile) \
  {                                          \
    pFile = strrchr(pPath, '/');             \
    if (!pFile)                              \
      pFile = strrchr(pPath, '\\');          \
    pFile = pFile ? ++pFile : pPath;         \
  }
#define BOF_COMPUTE_DELTA(start, end, delta)               \
  {                                                        \
    delta = (end > start) ? (end - start) : (start - end); \
  }
#define BOF_SAFE_FREE(p) \
  {                      \
    if ((p))             \
    {                    \
      free((void *)p);   \
    }                    \
    (p) = nullptr;       \
  } /*! free a buffer */
#define BOF_SAFE_DELETE(p) \
  {                        \
    if ((p))               \
    {                      \
      delete (p);          \
    }                      \
    (p) = nullptr;         \
  } /*! Delete an object*/
#define BOF_SAFE_DELETE_ARRAY(p) \
  {                              \
    if ((p))                     \
    {                            \
      delete[] (p);              \
    }                            \
    (p) = nullptr;               \
  } /*! Delete an array of objects*/
#define BOF_INC_TICKET_NUMBER(Cpt) \
  {                                \
    Cpt++;                         \
    if (Cpt == 0)                  \
      Cpt = 1;                     \
  } // No zero value
#define BOF_GTEST_EXPECT_BETWEEN(low, crt, high) \
  {                                              \
    EXPECT_GE(crt, low);                         \
    EXPECT_LE(crt, high);                        \
  }
#define BOF_NB_ELEM_IN_ARRAY(x) (sizeof((x)) / sizeof((x)[0]))
#define BOF_STRUCT_FIELD_OFFSET(Type, Field) (uintptr_t)(&(((Type *)0)->Field)) /*! Get structure field offset in \
                                                                                   byte*/
#define BOF_STRUCT_FIELD_SIZE(Type, Field) (sizeof(((Type *)0)->Field))         /*! Get structure field size in byte*/
#define BOF_SETORRESET_BIT_IN_BYTESTREAM(SetOrReset, BitNum, pByteStream) \
  {                                                                       \
    if (SetOrReset)                                                       \
    {                                                                     \
      pByteStream[BitNum >> 3] |= (1 << (BitNum & 0x07));                 \
    }                                                                     \
    else                                                                  \
    {                                                                     \
      pByteStream[BitNum >> 3] &= (0xFF - (1 << (BitNum & 0x07)));        \
    }                                                                     \
  }
#define BOF_ISBIT_IN_BYTESTREAM_SET(Sts, BitNum, pByteStream)          \
  {                                                                    \
    Sts = (pByteStream[BitNum >> 3] & (1 << (BitNum & 0x07))) ? 1 : 0; \
  }
#define BOF_ALIGN_PADDING_MAX(v, a) \
  ((((v) % (a)) != 0) ? ((a) - ((v) % (a))) : a) // If aligned add a zone of a byte before the next one
#define BOF_ALIGN_ADD_NB_PADDING_BYTE(v, a) \
  ((((v) % (a)) != 0) ? ((a) - ((v) % (a))) : 0) // If aligned add a zone of a byte before the next one
#define BOF_ALIGN_VALUE_ON(v, a) (((v) + (a)-1) & ~((a)-1))
#define BOF_SNPRINTF_NULL_CLIPPED(pBuffer, MaxBufferSize, Format, ...) \
  {                                                                    \
    snprintf(pBuffer, MaxBufferSize, Format, ##__VA_ARGS__);           \
    pBuffer[MaxBufferSize - 1] = 0;                                    \
  }
// Use Bof_StrNCpy #define BOF_STRNCPY_NULL_CLIPPED(pDst, pSrc, Count) {strncpy(pDst, pSrc, Count);pDst[Count-1]=0;}
#define BOF_SET_ADDRESS_MAGIC_NUMBER(p, mn)                                             \
  {                                                                                     \
    (p)->MagicNumber_U64 = (reinterpret_cast<uint64_t>(p) ^ static_cast<uint64_t>(mn)); \
  }
#define BOF_CHECK_ADDRESS_MAGIC_NUMBER(s, p, mn)                                                 \
  {                                                                                              \
    if (p)                                                                                       \
    {                                                                                            \
      s = ((reinterpret_cast<uint64_t>(p) ^ (p)->MagicNumber_U64) == static_cast<uint64_t>(mn)); \
    }                                                                                            \
    else                                                                                         \
      s = 0;                                                                                     \
  }
/*https://stackoverflow.com/questions/15832301/understanding-container-of-macro-in-the-linux-kernel
Taking this container for example:
struct container {
  int some_other_data;
  int this_data;
}
And a pointer int *my_ptr to the this_data member you'd use the macro to get a pointer to struct container *my_container
by using: struct container *my_container;	my_container = container_of(my_ptr, struct container, this_data);
*/
#define BOF_CONTAINER_OF(ptr, type, member)            \
  ({                                                   \
    const typeof(((type *)0)->member) *__mptr = (ptr); \
    (type *)((char *)__mptr - offsetof(type, member)); \
  })

// https://riptutorial.com/cplusplus/example/15335/casting-std--shared-ptr-pointers*/
// Note that std::reinterpret_pointer_cast is not available in C++11 and C++14, as it was only proposed by N3920 and
// adopted into Library Fundamentals TS in February 2014. However, it can be implemented as follows:
template <typename To, typename From>
inline std::shared_ptr<To> reinterpret_pointer_cast(std::shared_ptr<From> const &ptr) noexcept
{
  return std::shared_ptr<To>(ptr, reinterpret_cast<To *>(ptr.get()));
}

#define BOF_EXTERN_C extern "C"
#define BOF_EXTERN_C_BEGIN \
  extern "C"               \
  {
#define BOF_EXTERN_C_END \
  }                      \
  ;
extern uint32_t GL_BofDbgPrintfStartTime_U32;
#define BOF_DBG_PRINTF(Format, ...)                                                              \
  {                                                                                              \
    printf("%10d [%08X] " Format, BOF::Bof_GetMsTickCount() - BOF::GL_BofDbgPrintfStartTime_U32, \
           BOF::Bof_CurrentThreadId(), ##__VA_ARGS__);                                           \
  }

#if defined(NDEBUG) // We are in Release compil
// #define BOF_ASSERT(_Expression)	assert( (_Expression) )	//Void op by default in release
// Microsoft assert.h: #define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE(#_Expression),
// _CRT_WIDE(__FILE__), __LINE__), 0) ) #define BOF_ASSERT(_Expression) if (GL_BofStdParam_X.AssertInRelease_B){(void)(
// ( (_Expression) ) || (GL_BofStdParam_X.AssertCallback ?
// GL_BofStdParam_X.AssertCallback(__FILE__,__LINE__,#_Expression):printf("Assertion failed: %s, file %s, line %d\nPress
// any key followed by enter to abort the application...",#_Expression, __FILE__, __LINE__), getchar(), abort(), 0) );}
#define BOF_ASSERT(_Expression)                                                                                  \
  if (GL_BofStdParam_X.AssertInRelease_B)                                                                        \
  {                                                                                                              \
    int Ch_i;                                                                                                    \
    (void)(((_Expression)) ||                                                                                    \
           (GL_BofStdParam_X.AssertCallback                                                                      \
                ? static_cast<int>(GL_BofStdParam_X.AssertCallback(__FILE__, __LINE__, #_Expression))            \
                : printf("Assertion failed: %s, file %s, line %d\nPress any key followed by enter to abort the " \
                         "application...",                                                                       \
                         #_Expression, __FILE__, __LINE__),                                                      \
            Ch_i = getchar(), abort(), 0));                                                                      \
  }
// #define BOF_ASSERT(_Expression)
#else
// #define BOF_ASSERT(_Expression)	assert( (_Expression) )
#define BOF_ASSERT(_Expression)                                                                                  \
  {                                                                                                              \
    int Ch_i;                                                                                                    \
    (void)(((_Expression)) ||                                                                                    \
           (GL_BofStdParam_X.AssertCallback                                                                      \
                ? static_cast<int>(GL_BofStdParam_X.AssertCallback(__FILE__, __LINE__, #_Expression))            \
                : printf("Assertion failed: %s, file %s, line %d\nPress any key followed by enter to abort the " \
                         "application...",                                                                       \
                         #_Expression, __FILE__, __LINE__),                                                      \
            Ch_i = getchar(), abort(), 0));                                                                      \
  }
#endif

/*
 * 3 steps:
 * 1. Check if bit in first byte of current byte stream position
 * 2. If not found find first byte containing bits
 * 3. Scan byte to find bits
 */
#define BOF_LOOKFORBIT_BIT_IN_BYTESTREAM(SetOrReset, BitNum, MaxBitNum, pByteStream) \
  {                                                                                  \
    unsigned int i;                                                                  \
    bool StsBit;                                                                     \
    U32 FoundBitNum = (U32)-1;                                                       \
    uint8_t MaskOfFirstByte, Val;                                                    \
    MaskOfFirstByte = 0xFF ^ ((1 << (BitNum & 0x07)) - 1);                           \
    if (SetOrReset)                                                                  \
    {                                                                                \
      StsBit = (pByteStream[(BitNum >> 3)] & MaskOfFirstByte);                       \
    }                                                                                \
    else                                                                             \
    {                                                                                \
      StsBit = (pByteStream[(BitNum >> 3)] & MaskOfFirstByte) != MaskOfFirstByte;    \
    }                                                                                \
    if (!StsBit)                                                                     \
    {                                                                                \
      Val = SetOrReset ? 0x00 : 0xFF;                                                \
      for (i = (BitNum >> 3) + 1; i < (MaxBitNum >> 3); i++)                         \
      {                                                                              \
        if (pByteStream[i] != Val)                                                   \
        {                                                                            \
          StsBit = true;                                                             \
          break;                                                                     \
        }                                                                            \
      }                                                                              \
      BitNum = i << 3;                                                               \
    }                                                                                \
    if (StsBit)                                                                      \
    {                                                                                \
      for (i = BitNum; i < BitNum + 8; i++)                                          \
      {                                                                              \
        BOF_ISBIT_IN_BYTESTREAM_SET(StsBit, i, pByteStream);                         \
        if (StsBit == SetOrReset)                                                    \
        {                                                                            \
          FoundBitNum = i;                                                           \
          break;                                                                     \
        }                                                                            \
      }                                                                              \
    }                                                                                \
    BitNum = FoundBitNum;                                                            \
  }

#define BOF_SWAP16(ValToSwap)                                     \
  {                                                               \
    ((uint8_t *)&(ValToSwap))[0] ^= ((uint8_t *)&(ValToSwap))[1]; \
    ((uint8_t *)&(ValToSwap))[1] ^= ((uint8_t *)&(ValToSwap))[0]; \
    ((uint8_t *)&(ValToSwap))[0] ^= ((uint8_t *)&(ValToSwap))[1]; \
  }

#define BOF_SWAP16PTR(pValToSwap)                                 \
  {                                                               \
    ((uint8_t *)(pValToSwap))[0] ^= ((uint8_t *)(pValToSwap))[1]; \
    ((uint8_t *)(pValToSwap))[1] ^= ((uint8_t *)(pValToSwap))[0]; \
    ((uint8_t *)(pValToSwap))[0] ^= ((uint8_t *)(pValToSwap))[1]; \
  }

#define BOF_SWAP32(ValToSwap)                                     \
  {                                                               \
    ((uint8_t *)&(ValToSwap))[0] ^= ((uint8_t *)&(ValToSwap))[3]; \
    ((uint8_t *)&(ValToSwap))[3] ^= ((uint8_t *)&(ValToSwap))[0]; \
    ((uint8_t *)&(ValToSwap))[0] ^= ((uint8_t *)&(ValToSwap))[3]; \
    ((uint8_t *)&(ValToSwap))[1] ^= ((uint8_t *)&(ValToSwap))[2]; \
    ((uint8_t *)&(ValToSwap))[2] ^= ((uint8_t *)&(ValToSwap))[1]; \
    ((uint8_t *)&(ValToSwap))[1] ^= ((uint8_t *)&(ValToSwap))[2]; \
  }

#define BOF_SWAP32PTR(pValToSwap)                                 \
  {                                                               \
    ((uint8_t *)(pValToSwap))[0] ^= ((uint8_t *)(pValToSwap))[3]; \
    ((uint8_t *)(pValToSwap))[3] ^= ((uint8_t *)(pValToSwap))[0]; \
    ((uint8_t *)(pValToSwap))[0] ^= ((uint8_t *)(pValToSwap))[3]; \
    ((uint8_t *)(pValToSwap))[1] ^= ((uint8_t *)(pValToSwap))[2]; \
    ((uint8_t *)(pValToSwap))[2] ^= ((uint8_t *)(pValToSwap))[1]; \
    ((uint8_t *)(pValToSwap))[1] ^= ((uint8_t *)(pValToSwap))[2]; \
  }

#define BOF_SWAP64(ValToSwap)                                     \
  {                                                               \
    ((uint8_t *)&(ValToSwap))[0] ^= ((uint8_t *)&(ValToSwap))[7]; \
    ((uint8_t *)&(ValToSwap))[7] ^= ((uint8_t *)&(ValToSwap))[0]; \
    ((uint8_t *)&(ValToSwap))[0] ^= ((uint8_t *)&(ValToSwap))[7]; \
    ((uint8_t *)&(ValToSwap))[1] ^= ((uint8_t *)&(ValToSwap))[6]; \
    ((uint8_t *)&(ValToSwap))[6] ^= ((uint8_t *)&(ValToSwap))[1]; \
    ((uint8_t *)&(ValToSwap))[1] ^= ((uint8_t *)&(ValToSwap))[6]; \
    ((uint8_t *)&(ValToSwap))[2] ^= ((uint8_t *)&(ValToSwap))[5]; \
    ((uint8_t *)&(ValToSwap))[5] ^= ((uint8_t *)&(ValToSwap))[2]; \
    ((uint8_t *)&(ValToSwap))[2] ^= ((uint8_t *)&(ValToSwap))[5]; \
    ((uint8_t *)&(ValToSwap))[3] ^= ((uint8_t *)&(ValToSwap))[4]; \
    ((uint8_t *)&(ValToSwap))[4] ^= ((uint8_t *)&(ValToSwap))[3]; \
    ((uint8_t *)&(ValToSwap))[3] ^= ((uint8_t *)&(ValToSwap))[4]; \
  }

#define BOF_SWAP64PTR(pValToSwap)                                 \
  {                                                               \
    ((uint8_t *)(pValToSwap))[0] ^= ((uint8_t *)(pValToSwap))[7]; \
    ((uint8_t *)(pValToSwap))[7] ^= ((uint8_t *)(pValToSwap))[0]; \
    ((uint8_t *)(pValToSwap))[0] ^= ((uint8_t *)(pValToSwap))[7]; \
    ((uint8_t *)(pValToSwap))[1] ^= ((uint8_t *)(pValToSwap))[6]; \
    ((uint8_t *)(pValToSwap))[6] ^= ((uint8_t *)(pValToSwap))[1]; \
    ((uint8_t *)(pValToSwap))[1] ^= ((uint8_t *)(pValToSwap))[6]; \
    ((uint8_t *)(pValToSwap))[2] ^= ((uint8_t *)(pValToSwap))[5]; \
    ((uint8_t *)(pValToSwap))[5] ^= ((uint8_t *)(pValToSwap))[2]; \
    ((uint8_t *)(pValToSwap))[2] ^= ((uint8_t *)(pValToSwap))[5]; \
    ((uint8_t *)(pValToSwap))[3] ^= ((uint8_t *)(pValToSwap))[4]; \
    ((uint8_t *)(pValToSwap))[4] ^= ((uint8_t *)(pValToSwap))[3]; \
    ((uint8_t *)(pValToSwap))[3] ^= ((uint8_t *)(pValToSwap))[4]; \
  }

#define BOF_BIND_0_ARG_TO_METHOD(pThis, Class_ColonColon_Method) std::bind(&Class_ColonColon_Method, pThis)
#define BOF_BIND_1_ARG_TO_METHOD(pThis, Class_ColonColon_Method) \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1)
#define BOF_BIND_2_ARG_TO_METHOD(pThis, Class_ColonColon_Method) \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2)
#define BOF_BIND_3_ARG_TO_METHOD(pThis, Class_ColonColon_Method) \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)
#define BOF_BIND_4_ARG_TO_METHOD(pThis, Class_ColonColon_Method)                                                  \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, \
            std::placeholders::_4)
#define BOF_BIND_5_ARG_TO_METHOD(pThis, Class_ColonColon_Method)                                                  \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, \
            std::placeholders::_4, std::placeholders::_5)
#define BOF_BIND_6_ARG_TO_METHOD(pThis, Class_ColonColon_Method)                                                  \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, \
            std::placeholders::_4, std::placeholders::_5, std::placeholders::_6)
#define BOF_BIND_7_ARG_TO_METHOD(pThis, Class_ColonColon_Method)                                                  \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, \
            std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7)
#define BOF_BIND_8_ARG_TO_METHOD(pThis, Class_ColonColon_Method)                                                  \
  std::bind(&Class_ColonColon_Method, pThis, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, \
            std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7,           \
            std::placeholders::_8)

BOFSTD_EXPORT BOFERR Bof_Initialize(BOFSTDPARAM &_rStdParam_X);

BOFSTD_EXPORT BOFERR Bof_Shutdown();

BOFSTD_EXPORT std::string Bof_GetVersion();

// For BOF error code
BOFSTD_EXPORT const char *Bof_ErrorCode(BOFERR _ErrorCode_E);
// For WIN32 or linux system error code
BOFSTD_EXPORT std::string Bof_SystemErrorCode(uint32_t _ErrorCode_U32);

BOFSTD_EXPORT bool Bof_IsWindows();
BOFSTD_EXPORT bool Bof_AmIRunningInsideDocker();

template <typename T>
BOFERR Bof_StringToBin(uint32_t _Base_U32, const char *_pAsciiNumber_c, T &_rConvertedValue)
{
  BOFERR Rts_E = BOF_ERR_EINVAL;
  char *p_c;
  int64_t Nb_S64;

  _rConvertedValue = 0;
  if ((_pAsciiNumber_c) && ((_Base_U32 == 0) || ((_Base_U32 >= 2) && (_Base_U32 <= 36))))
  {
    Nb_S64 = strtol(_pAsciiNumber_c, &p_c, _Base_U32);
    if (*p_c == 0) // else not a number
    {
      Rts_E = BOF_ERR_NO_ERROR;
      _rConvertedValue = static_cast<T>(Nb_S64);
    }
    else
    {
      Rts_E = BOF_ERR_ENOKEY;
    }
  }
  return Rts_E;
}

template <typename T>
inline T BOF_MIN(T _Val1, T _Val2)
{
  return (_Val1 < _Val2) ? _Val1 : _Val2;
}

template <typename T>
inline T BOF_MAX(T _Val1, T _Val2)
{
  return (_Val1 > _Val2) ? _Val1 : _Val2;
}

class BOFSTD_EXPORT BofException : public std::exception
{
public:
  BofException(std::string _Header_S, std::string _Context_S = "", std::string _Where_S = "",
               int32_t _ErrorCode_S32 = 0);
  char const *what() const noexcept override; // throw ();

private:
  std::string mHeader_S;
  BOFERR mErrorCode_E;
  std::string mContext_S;
  std::string mWhere_S;

  std::string mMessage_S;
};
#define THROW_BOF_EXCEPTION(Header, Context, ErrorCode)                   \
  {                                                                       \
    std::ostringstream Where;                                             \
    Where << __FILE__ << ':' << __LINE__ << " (" << __func__ << ')';      \
    BOF::BofException Exception(Header, Context, Where.str(), ErrorCode); \
    throw Exception;                                                      \
  }

END_BOF_NAMESPACE()

extern BOFSTD_EXPORT BOF::BOFSTDPARAM GL_BofStdParam_X;
